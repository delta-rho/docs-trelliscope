<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Trelliscope: Detailed Vis of Large Complex Data in R</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <link href="assets/bootstrap/css/bootstrap.css" rel="stylesheet">
    <link href="assets/custom/custom.css" rel="stylesheet">
    <!-- font-awesome -->
    <link href="assets/font-awesome/css/font-awesome.min.css" rel="stylesheet">

    <!-- prism -->
    <link href="assets/prism/prism.css" rel="stylesheet">
    <link href="assets/prism/prism.r.css" rel="stylesheet">
    <script type='text/javascript' src='assets/prism/prism.js'></script>
    <script type='text/javascript' src='assets/prism/prism.r.js'></script>
    
    
    
    <script type="text/javascript" src="assets/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
   MathJax.Hub.Config({    
     extensions: ["tex2jax.js"],    
     "HTML-CSS": { scale: 100}    
   });
   </script>
    
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="js/html5shiv.js"></script>
    <![endif]-->
    
    <link href='http://fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>
    <!-- <link href='http://fonts.googleapis.com/css?family=Lustria' rel='stylesheet' type='text/css'> -->
    <link href='http://fonts.googleapis.com/css?family=Bitter' rel='stylesheet' type='text/css'>
    

    <!-- Fav and touch icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="ico/apple-touch-icon-114-precomposed.png">
      <link rel="apple-touch-icon-precomposed" sizes="72x72" href="ico/apple-touch-icon-72-precomposed.png">
                    <link rel="apple-touch-icon-precomposed" href="ico/apple-touch-icon-57-precomposed.png">
                                   <!-- <link rel="shortcut icon" href="ico/favicon.png"> -->
  </head>

  <body>

    <div class="container-narrow">

      <div class="masthead">
        <ul class="nav nav-pills pull-right">
           <li class='active'><a href='index.html'>Docs</a></li><li class=''><a href='functionref.html'>Function Ref</a></li><li><a href='https://github.com/hafen/trelliscope'>Github <i class='fa fa-github'></i></a></li>
        </ul>
        <p class="myHeader">Trelliscope: Detailed Vis of Large Complex Data in R</p>
      </div>

      <hr>

<div class="container-fluid">
   <div class="row-fluid">
   
   <div class="col-md-3 well">
   <ul class = "nav nav-list" id="toc">
   <li class='nav-header unselectable' data-edit-href='https://github.com/hafen/trelliscope/edit/gh-pages/docs/1intro.Rmd'>Intro</li>
      
      <li class='active'>
         <a target='_self' class='nav-not-header' href='#background'>Background</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#getting-started'>Getting Started</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#trellis-display'>Trellis Display</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#visualization-databases'>Visualization Databases</a>
      </li>


<li class='nav-header unselectable' data-edit-href='https://github.com/hafen/trelliscope/edit/gh-pages/docs/2displays.Rmd'>Trelliscope Displays</li>
      
      <li class='active'>
         <a target='_self' class='nav-not-header' href='#division-with-datadr'>Division with datadr</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#a-bare-bones-display'>A Bare Bones Display</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#axis-limits'>Axis Limits</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#cognostics'>Cognostics</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#panel-storage'>Panel Storage</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#cognostics-storage'>Cognostics Storage</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#linking-displays'>Linking Displays</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#scatterplot-displays'>Scatterplot Displays</a>
      </li>


<li class='nav-header unselectable' data-edit-href='https://github.com/hafen/trelliscope/edit/gh-pages/docs/3viewer.Rmd'>Viewing Displays</li>
      
      <li class='active'>
         <a target='_self' class='nav-not-header' href='#shiny-viewer'>Shiny Viewer</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#cognostics-interactions'>Cognostics Interactions</a>
      </li>


<li class='nav-header unselectable' data-edit-href='https://github.com/hafen/trelliscope/edit/gh-pages/docs/4webnotebook.Rmd'>Lab Notebooks</li>
      
      <li class='active'>
         <a target='_self' class='nav-not-header' href='#creating-a-notebook'>Creating a Notebook</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#syncing-files-with-the-web'>Syncing Files With the Web</a>
      </li>


<li class='nav-header unselectable' data-edit-href='https://github.com/hafen/trelliscope/edit/gh-pages/docs/5misc.Rmd'>Misc</li>
      
      <li class='active'>
         <a target='_self' class='nav-not-header' href='#scalable-system'>Scalable System</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#faq'>FAQ</a>
      </li>


      <li class='active'>
         <a target='_self' class='nav-not-header' href='#r-code'>R Code</a>
      </li>

   </ul>
   </div>

<div class="col-md-9 tab-content" id="main-content">

<div class='tab-pane active' id='background'>
<h3>Background</h3>

<p>Trelliscope provides a way to visualize large, complex data in great detail from within the R statistical programming environment.  This package operates on data that has been split into subsets using the <a href="http://github.com/hafen/datadr">datadr</a> package.  Data can be local R data objects or can be very large data sets supported by the <a href="http://github.com/saptarshiguha/RHIPE">RHIPE</a> backend of <code>datadr</code>.</p>

<p>Trelliscope is based on the concept of Divide and Recombine (D&amp;R).  Some philosophy and background on D&amp;R can be found at <a href="http://www.datadr.org">datadr.org</a>.</p>

<h4>Reference</h4>

<p>Related projects:</p>

<ul>
<li><a href="http://github.com/hafen/datadr">datadr</a>: R package providing the D&amp;R framework</li>
<li><a href="http://github.com/saptarshiguha/RHIPE">RHIPE</a>: the engine that enables D&amp;R to work with large, complex data</li>
</ul>

<p>References:</p>

<ul>
<li><a href="http://datadr.org">http://datadr.org</a></li>
<li><a href="http://ml.stat.purdue.edu/gaby/trelliscope.ldav.2013.pdf">Trelliscope: A System for Detailed Visualization in the Deep Analysis of Large Complex Data</a></li>
<li><a href="http://onlinelibrary.wiley.com/doi/10.1002/sta4.7/full">Large complex data: divide and recombine (D&amp;R) with RHIPE</a></li>
<li><a href="http://jmlr.csail.mit.edu/proceedings/papers/v5/guha09a/guha09a.pdf">Visualization Databases for the Analysis of Large Complex Datasets</a></li>
</ul>

</div>


<div class='tab-pane' id='getting-started'>
<h3>Getting Started</h3>

<p>Trelliscope is a part of and depends on <code>datadr</code>.  It is recommended to spend some time in the <code>datadr</code> <a href="http://hafen.github.io/datadr/index.html">tutorial</a> to get acquainted with the package.  Mainly focusing on the <a href="http://hafen.github.io/datadr/index.html#division">division</a> aspects and the <a href="http://hafen.github.io/datadr/index.html#backend-choices">backend options</a> of the package will suffice, although it is recommended to get well-acquainted with the entire package, as Trelliscope is simply a visualization component in the D&amp;R analysis paradigm.</p>

<h4>Installation</h4>

<p>To install Trelliscope, we must first install <code>datadr</code>, which is discussed <a href="http://hafen.github.io/datadr/index.html#getting-started">here</a>.</p>

<p>Then, to install Trelliscope:</p>

<pre><code class="r">library(devtools)
install_github(&quot;trelliscope&quot;, &quot;hafen&quot;)
</code></pre>

<p>Then we load the package:</p>

<pre><code class="r">library(trelliscope)
</code></pre>

<pre><code>Loading required package: datadr
Loading required package: parallel
Loading required package: data.table
data.table 1.9.2  For help type: help(&quot;data.table&quot;)
Loading required package: codetools
Loading required package: hexbin
Loading required package: grid
Loading required package: lattice
Loading required package: testthat
Loading required package: base64enc
Loading required package: shiny
Loading required package: ggplot2
</code></pre>

<p>and we are ready to go.</p>

<h4>Connecting to a Visualization Database (VDB)</h4>

<p>Collections of Trelliscope and other displays created throughout the course of an analysis are organized into a visualization database (VDB) for the project.  Displays can be organized into groups by analysis thread.</p>

<p>The first step to using Trelliscope for an analysis project is to connect to a VDB.  A VDB connection is simply a connection to a directory on disk where all of the VDB files reside or will reside.</p>

<pre><code class="r"># initialize a connection to a new VDB to be located at /private/tmp/vdbtest
vdbDir &lt;- &quot;/private/tmp/vdbtest&quot;
conn &lt;- vdbConn(vdbDir, autoYes=TRUE, name=&quot;myProject&quot;)
</code></pre>

<p>If the VDB connection directory doesn&#39;t exist, it will ask whether it should be created.  Here, we specify <code>autoYes=TRUE</code> to automatically answer yes to this question.  In any subsequent R session, we can connect to the existing VDB directory with the same <code>vdbConn()</code> command.</p>

<p>Most Trelliscope functions need the VDB connection information to know where to put things.  It can be tedious to always supply this, so <code>vdbConn()</code> sets a global R option called <code>&quot;vdbConn&quot;</code> that store the connection information.  If in a Trelliscope function we do not explicitly specify the connection, the default is to search for the global <code>vdbConn</code> option.  The assumption is that in any one R session, the user will be using just one VDB, and thus there will not be multiple conflicting connections.</p>

<p>We can now look at some examples and start populating the VDB with displays.</p>

</div>


<div class='tab-pane' id='trellis-display'>
<h3>Trellis Display</h3>

<p>In this section, we will explore an example dataset using the <code>lattice</code> package, which is based on Trellis Display, upon which many of the principles of Trelliscope are built.  Note that lattice is not required for plotting in Trelliscope - you can use <code>ggplot2</code>, base R graphics, or potentially any other plotting mechanism that can be rendered in a web page.</p>

<h4><code>airplane</code> data</h4>

<p>The Trelliscope package includes a dataset called <code>airplane</code> which we will use as an example dataset in this tutorial.  This data is very small and can be analyzed quite easily without the help of trelliscope, but we use it to demonstrate the functionality.  Bear in mind that the same tools apply to much larger data.</p>

<p>Let&#39;s first get a feel for the data:</p>

<pre><code class="r">data(airplane)
head(airplane)
</code></pre>

<pre><code>              dat_ams    org    NO3    SO4    NH4      CHL org_err NO3_err
1 2010-06-28 16:25:21  9.263 0.4490 0.1149 0.1256 0.011193  0.1108 0.01721
2 2010-06-28 16:25:34 13.288 0.5890 0.1925 0.2286 0.017478  0.1165 0.01809
3 2010-06-28 16:25:46 12.134 0.5356 0.2323 0.2240 0.006066  0.1161 0.01768
4 2010-06-28 16:25:59 12.357 0.5700 0.3070 0.1785 0.033465  0.1164 0.01820
5 2010-06-28 16:26:12 10.112 0.4567 0.1975 0.1718 0.006830  0.1146 0.01746
6 2010-06-28 16:26:24  7.493 0.2889 0.2048 0.1078 0.036566  0.1116 0.01657
  SO4_err NH4_err CHl_err latitude longitude altitude static_p altitude_p
1 0.02220 0.03308 0.01238    38.73    -121.4    353.6    967.7      327.2
2 0.02444 0.03305 0.01217    38.73    -121.3    368.7    966.1      340.8
3 0.02517 0.03307 0.01231    38.74    -121.3    384.7    964.3      356.4
4 0.02533 0.03322 0.01227    38.74    -121.3    393.2    963.4      364.9
5 0.02503 0.03313 0.01225    38.75    -121.3    388.1    963.9      360.0
6 0.02412 0.03303 0.01193    38.75    -121.3    379.5    964.8      352.0
  static_t potential_t dewpt    RH h2o_MF windspd winddir cpc_3025
1    28.43       31.34 14.13 41.64 10.544    3.45   329.8     5508
2    28.66       31.66 13.50 39.34 10.114    3.90   325.0     3915
3    28.60       31.72 13.38 39.28 10.054    4.14   320.2     4037
4    28.51       31.71 12.94 38.48  9.796    4.12   317.8     3969
5    28.80       31.98 11.10 33.50  8.680    4.70   317.4     3567
6    28.84       31.94 11.50 34.18  8.872    4.54   316.6     2940
  cpc_3010 ozone    co so2     no    no2   noy mz_33   mz_42 mz_45 mz_59
1    482.8 46.79 109.7  NA 0.3074 1.7454 5.245 16.73 0.10241 5.985 8.495
2    352.4 44.28  97.6  NA 0.0514 0.3584 3.476 14.58 0.11756 5.216 7.713
3    364.4 45.18 101.2  NA 0.1456 0.5726 4.092 14.42 0.13327 5.188 6.852
4    348.0 45.50 103.1  NA 0.1593 0.6876 4.024 14.08 0.09164 4.843 7.080
5    314.0 40.42  91.8  NA 0.1150 0.8004 3.528 11.14 0.04075 5.075 6.459
6    263.2 40.14  87.8  NA 0.0354 0.3476 3.045 10.69 0.05883 4.171 4.851
   mz_69 mz_71  mz_79  mz_93 mz_107  mz_137 mz_43 mz_61  mz_87 mz69_71
1 1.5888 3.880 0.4166 0.4464 0.6861 0.51914 8.521 5.386 0.3025   5.469
2 0.8105 3.654 0.2426 0.5712 0.8691 0.45182 8.299 5.125 0.2352   4.464
3 0.7905 3.345 0.1917 0.4538 0.6606 0.09299 8.169 5.097 0.4179   4.136
4 0.9043 2.939 0.2614 0.2178 0.7805 0.35259 8.377 5.169 0.2983   3.843
5 0.9109 2.744 0.1778 0.1849 0.2648 0.34773 6.872 4.961 0.3636   3.655
6 1.1104 1.878 0.1725 0.1533 0.8381 0.16363 7.049 4.566 0.2459   2.988
  leg_flag    nox
1       13 2.0528
2       13 0.4098
3       13 0.7182
4       13 0.8469
5        3 0.9154
6        3 0.3830
</code></pre>

<p>We see a date/time variable, latitude, longitude, altitude, and several measurements.  Here we will focus on the measurement of <code>co</code>.</p>

<h4><code>co</code> vs. time</h4>

<p>Let&#39;s take a look at <code>co</code> vs. time:</p>

<pre><code class="r"># look at co vs. time
Sys.setenv(TZ=&quot;UTC&quot;)
xyplot(co ~ dat_ams, data=airplane, aspect=0.2)
</code></pre>

<p><img src="figures/knitr/airplane_time.png" alt="plot of chunk airplane_time"> </p>

<p>This plots <code>co</code> vs. <code>dat_ams</code>, and gives the plot an aspect ratio of 0.2.  Note that aspect ratios are very important for visual perception and should not be an afterthought or not thought of at all when creating a display.</p>

<p>It looks like there are several <code>co</code> measurements over the course of a day, split into two chunks with a 4-5 hour gap in between.  It turns out that there are two separate flights - one in the morning and one in the afternoon.</p>

<p>To account for this in our analyses, let&#39;s create a new variable <code>flight</code> with values <code>&quot;am&quot;</code> and <code>&quot;pm&quot;</code>:</p>

<pre><code class="r"># distinguish &quot;am&quot; and &quot;pm&quot; flights
midTime &lt;- as.POSIXct(&quot;2010-06-28 21:00:00 UTC&quot;)
airplane$flight &lt;- ifelse(airplane$dat_ams &lt; midTime, &quot;am&quot;, &quot;pm&quot;)
</code></pre>

<h4>Altitude vs. time</h4>

<p>Another interesting variable is altitude.  If we look at altitude vs. time:</p>

<pre><code class="r"># look at altitude vs. time
xyplot(altitude ~ dat_ams, data=airplane, aspect=0.2)
</code></pre>

<p><img src="figures/knitr/ap_alt.png" alt="plot of chunk ap_alt"> </p>

<p>We see that altitude typically stays fairly constant a little under 500 and 1000, with some interesting quick ascents to higher altitudes.  It may be interesting to investigate different altitude levels, and we can create a discretized altitude variable:</p>

<pre><code class="r"># create a discrete version of altitude
airplane$altCut &lt;- cut(airplane$altitude, seq(0, 3000, by=500))
</code></pre>

<h4>Flight tracks</h4>

<p>We can get a feel for the flight tracks during each flight with the following:</p>

<pre><code class="r"># take a look at airplane tracks
xyplot(latitude ~ longitude, data=airplane,
   groups=flight,
   aspect=&quot;iso&quot;,
   alpha=0.5,
   auto.key=list(space=&quot;right&quot;)
)
</code></pre>

<p><img src="figures/knitr/ap_tracks.png" alt="plot of chunk ap_tracks"> </p>

<p>The <code>groups</code> argument tells lattice to use a different color to plot data corresponding to each flight.  <code>aspect=&quot;iso&quot;</code> forces the aspect ratio of the plot to be such that the units of the x and y axis are equal according to the physical screen space they cover relative to their units.</p>

<h4>Adding altitude</h4>

<p>Suppose we want to incorporate altitude into the tracks plot.  There are several ways we could do this.  Here, for each flight we plot the tracks colored differently for each level of altitude.</p>

<pre><code class="r"># look at tracks with altitude and flight
library(RColorBrewer)
xyplot(latitude ~ longitude | flight, 
   data=airplane,
   panel=function(x, y, ...) {
      panel.fill(&quot;#E0E0E0&quot;)
      panel.grid(h=-1, v=-1, col=&quot;lightgray&quot;)
      panel.xyplot(x, y, ...)
   },
   groups=altCut,
   between=list(x=0.5),
   aspect=&quot;iso&quot;,
   par.settings=list(superpose.symbol=list(col=brewer.pal(6, &quot;Accent&quot;))),
   auto.key=list(space=&quot;right&quot;)
)
</code></pre>

<p><img src="figures/knitr/ap_tracks_alt.png" alt="plot of chunk ap_tracks_alt"> </p>

<p>This display introduces several more elements of Trellis Display.  The most important is <em>conditioning</em>, or <em>faceting</em> on the variable <code>flight</code>.  In the R formula interface, this is specified by the <code>|</code> operator.  This causes a panel to be rendered independently for each subset defined by the levels of <code>flight</code>.</p>

<p>Another notion introduced in this example is that of a panel function.  The panel function provides instructions for what to plot for each panel in the display, and the input to the panel function is a subset of data as specified by the conditioning variables.  The default panel function for <code>xyplot()</code> is <code>panel.xyplot()</code>.  Here, we use that, but additionally fill the background of each panel and add grid lines (which can also be done by specifying <code>type=c(&quot;p&quot;, &quot;g&quot;)</code>).</p>

<p>Other aspects introduced here include the key, specified by <code>auto.key</code>, and special settings for the color of the symbols, specified by <code>par.settings</code>.  There are several aspects of Trellis Display as implemented in the <code>lattice</code> package that we encourage you to look into on your own, starting <a href="http://lmdvr.r-forge.r-project.org/figures/figures.html">here</a>.</p>

<h4>More on conditioning</h4>

<p>As conditioning is the basis of Trelliscope display, we&#39;ll cover a few more examples of conditioning, paying particular attention the importance of axis limits for being able to make meaningful judgements of similarities or differences between panels.</p>

<p>Let&#39;s take a look at the airplane tracks broken up by time.  First, we will create a new factor variable that groups time by 15 minute intervals:</p>

<pre><code class="r"># break time into 15 minute intervals
airplane$datCut &lt;- sprintf(&quot;%s:%02d&quot;,
   format(airplane$dat_ams, &quot;%m-%d/%H&quot;), 
   floor(as.integer(format(airplane$dat_ams, &quot;%M&quot;)) / 15) * 15
)
</code></pre>

<p>One way we might view the data conditioned on this new time variable is to plot a directional arrow of the flight&#39;s path per time interval:</p>

<pre><code class="r"># plot of airplane tracks by 15 minute intervals
arrowPanel &lt;- function(x, y, ...) {
   n &lt;- length(x)
   panel.grid(h=-1, v=-1)
   panel.arrows(x[1:(n-1)], y[1:(n-1)], x[2:n], y[2:n], length=0.05, alpha=0.3, col=&quot;blue&quot;)
}

xyplot(latitude ~ longitude | datCut,
   data=airplane,
   panel=arrowPanel,
   as.table=TRUE,
   between=list(x=0.25, y=0.25),
   layout=c(5, 2),
   aspect=&quot;iso&quot;,
   subset=flight==&quot;pm&quot;
)
</code></pre>

<p><img src="figures/knitr/tracks_datcut.png" alt="plot of chunk tracks_datcut"> </p>

<h4>Scales / axis limits</h4>

<p>Using this example, an important issue to discuss with Trellis Display is that of <em>scales</em>.  When viewing panels of a Trellis display, meaningful visual comparisons between panels greatly depend on how the limits of the x and y axes are determined.  There are three choices for each axis:</p>

<ul>
<li><strong>&quot;same&quot;</strong>: the same limits are used for all the panels</li>
<li><strong>&quot;free&quot;</strong>: the limits for each panel are determined by just the points in that panel</li>
<li><strong>&quot;sliced&quot;</strong>:  the length (max - min) of the scales are constrained to remain the same across panels</li>
</ul>

<p>Determining suitable axis limits is dependent on what is being visualized, but typically &quot;same&quot; or &quot;sliced&quot; are good choices as they enable panel-to-panel comparisons, which is where much of the power of this type of visualization lies.  You might choose &quot;sliced&quot; if you are interested in relative behaviors in terms of scale, or &quot;same&quot; if you are interested in relative behaviors both in terms of location and scale.</p>

<p>The handling of panel axis limits is specified by the <code>scales</code> argument, which takes a names list of lists with names <code>x</code> and <code>y</code> for the x and y axes respectively.  There are several options to specify for each axis scale, but <code>relation</code> specifies the axis limit behavior.</p>

<p>The default in <code>lattice</code> is &quot;same&quot;, and we have seen an example of this in our previous plot.  Let&#39;s also look at the other options.</p>

<h4>Free axes</h4>

<p>Here is the same plot as before but with both axes &quot;free&quot;:</p>

<pre><code class="r"># example of both x and y axes &quot;free&quot;
xyplot(latitude ~ longitude | datCut,
   data=airplane,
   panel=arrowPanel,
   as.table=TRUE,
   between=list(x=0.25, y=0.25),
   layout=c(5, 2),
   scales=list(x=list(relation=&quot;free&quot;), y=list(relation=&quot;free&quot;)),
   subset=flight==&quot;pm&quot;
)
</code></pre>

<p><img src="figures/knitr/tracks_free.png" alt="plot of chunk tracks_free"> </p>

<p>It is quite difficult to understand how things vary between panels in this plot.</p>

<h4>Sliced axes</h4>

<p>Here is the plot with both axes &quot;sliced&quot;:</p>

<pre><code class="r"># example of both x and y axes &quot;sliced&quot;
xyplot(latitude ~ longitude | datCut,
   data=airplane,
   panel=arrowPanel,
   as.table=TRUE,
   between=list(x=0.25, y=0.25),
   layout=c(5, 2),
   scales=list(x=list(relation=&quot;sliced&quot;), y=list(relation=&quot;sliced&quot;)),
   subset=flight==&quot;pm&quot;
)
</code></pre>

<p><img src="figures/knitr/tracks_sliced.png" alt="plot of chunk tracks_sliced"> </p>

<p>Now we can make relative judgements between panels, but it is difficult to judge the magnitude of shifts in location from one panel to the other.</p>

<h4>The prepanel function</h4>

<p>One more notion to introduce in Trellis Display that will translate over to Trelliscope is that of a <em>prepanel function</em>.  A prepanel function can be used to determine the individual panel x and y axis data ranges from which the &quot;same&quot;, &quot;free&quot;, or &quot;sliced&quot; axis computations will be based.  </p>

<p>For example, suppose you are introducing other visual artifact to your panels other than the original data being plotted, and you would like to make sure that the axis limits account for the possibility of these extending beyond the range of the data being plotted.</p>

<p>Here is an example of using a prepanel function to specify that the axis limits should extend beyond the range of both the x and y-axis variables by 1 unit in each direction.  The prepanel function, like the panel function, takes the current x and y variables and must return a list that includes <code>xlim</code> and <code>ylim</code> which specify the axis limit range for each panel.</p>

<pre><code class="r"># prepanel example
xyplot(latitude ~ longitude | datCut,
   data=airplane,
   panel=arrowPanel,
   prepanel=function(x, y) {
      list(xlim=range(x) + c(-1, 1), ylim=range(y) + c(-1, 1))
   },
   as.table=TRUE,
   between=list(x=0.25, y=0.25),
   layout=c(5, 2),
   scales=list(x=list(relation=&quot;free&quot;), y=list(relation=&quot;free&quot;)),
   subset=flight==&quot;pm&quot;
)
</code></pre>

<p><img src="figures/knitr/tracks_prepanel.png" alt="plot of chunk tracks_prepanel"> </p>

<!-- latCuts <- seq(38.2, 39.4, by=0.1)
lonCuts <- seq(-121.8, -120.8, by=0.1)

xyplot(latitude ~ longitude, data=airplane,
   groups=airplane$dat_ams < as.POSIXct("2010-06-28 21:00:00 UTC"),
   panel=function(x, y, ...) {
      panel.abline(v=lonCuts, col="gray")
      panel.abline(h=latCuts, col="gray")
      panel.xyplot(x, y, ...)
   },
   aspect="iso"
) -->

</div>


<div class='tab-pane' id='visualization-databases'>
<h3>Visualization Databases</h3>

<!-- Now that we have looked a little at the data and covered some of the principles of Trellis Display, before moving on to Trelliscope Displays, let's first discuss how we can populate a visualization database with displays. -->

<p>Throughout the course of an analysis, we create several visual displays, such as those seen so far.  To help both keep track of what has been done and communicate our work to others, we can organize our displays in a <em>visualization database</em> (VDB).  </p>

<p>In Trelliscope, a VDB is a collection of display objects that can either be simple plots created from various R plotting packages, like the ones we have seen so far, or Trelliscope displays, which are displays created for a divided dataset with a potentially very large number of subsets.  This type of display is discussed in detail in the <a href="#division-with-datadr">Trelliscope Displays</a> section.  Trelliscope provides a way to view and interact with these displays, as well as easily embed them in a web notebook, which we discuss in the <a href="#viewing-displays">Viewing Displays</a> and <a href="#lab-notebooks">Lab Notebooks</a> sections.</p>

<p>Here, we will get introduced to a few of the commands for interacting with a VDB using Trelliscope. </p>

<h4>Connecting to a VDB</h4>

<p>We have already initialized a VDB.  If we are in a new R session, we can re-connect to the VDB with the following:</p>

<pre><code class="r"># re-connect to our VDB
conn &lt;- vdbConn(&quot;/private/tmp/vdbtest&quot;)
</code></pre>

<p>The other information about the VDB connection (such as its name) have been stored and are read in.  If you would like to reset a VDB connection&#39;s settings (such as for changing the VDB name), you can add <code>reset=TRUE</code> to the call.</p>

<p>Recall that <code>vdbConn()</code> sets a global option with the connection information such that all methods have access to this information without explicitly supplying the connection object all the time.</p>

<h4>Adding a display to a VDB</h4>

<p>Plots created with R packages <code>lattice</code> or <code>ggplot2</code>, as well as with any R expression that plots to a graphics device, can be added to a VDB with the function <code>addDisplay()</code>.  We will cover that here, and in the next section we will see how to create and add Trelliscope displays to a VDB.</p>

<p>Say that we would like to add one of our plots we have created so far to our VDB:</p>

<pre><code class="r"># add a lattice plot to our VDB
p &lt;- xyplot(latitude ~ longitude | flight, 
   data=airplane,
   panel=function(x, y, ...) {
      panel.fill(&quot;#E0E0E0&quot;)
      panel.grid(h=-1, v=-1, col=&quot;lightgray&quot;)
      panel.xyplot(x, y, ...)
   },
   groups=altCut,
   between=list(x=0.5),
   aspect=&quot;iso&quot;,
   par.settings=list(superpose.symbol=list(col=brewer.pal(6, &quot;Accent&quot;))),
   auto.key=list(space=&quot;right&quot;))

addDisplay(p, 
   name  = &quot;tracks_byflight&quot;, 
   group = &quot;exploratory&quot;,
   desc  = &quot;The tracks of the airplane with a panel for each of the morning and evening flights.  Color by altitude of plane.&quot;,
   dim   = list(width=800, height=450, res=150))
</code></pre>

<p>There are three attributes we can specify to describe a display record being added to the VDB:</p>

<ul>
<li><code>name</code>: the name of the display</li>
<li><code>group</code>: the group the display belongs to (default is <code>&quot;common&quot;</code>)</li>
<li><code>desc</code>: a description of the display</li>
</ul>

<p>It is sufficient to just specify <code>name</code>, but specifying <code>group</code> is also recommended and is used to help organize plots by different aspects of the analysis.  It is also a good practice to provide a detailed description of the plot.</p>

<p>The <code>dim</code> argument is a list specifying the width and height of the resulting plot (in pixels), and the resolution of the raster image that will be created.</p>

<p>Adding displays to our VDB helps us document our displays in line with our analyses.  This makes the process of dissemination much easier, as we will see.  In the course of analysis, we can create many ineffective displays in our quest to understand the data.  But the displays that are insightful deserve the extra care of being documented and added to the VDB.</p>

<h4>What a display looks like in the VDB</h4>

<p>So what is actually happening when we create a display?  Trelliscope creates a directory for the display in the VDB directory and fills it with various pieces of metadata.  It also can hold the actual rendered panels, as is the case here.</p>

<p>Let&#39;s see what got created for this display:</p>

<pre><code class="r"># list the files in the &quot;displays&quot; directory of the VDB
list.files(file.path(vdbDir, &quot;displays&quot;))
</code></pre>

<pre><code>[1] &quot;_displayList.Rdata&quot; &quot;exploratory&quot;       
</code></pre>

<p>We see a file <code>_displayList.Rdata</code>, which is an object containing the grand list of all displays, as well as various pieces of metadata about the displays.  The other file, <code>&quot;exploratory&quot;</code> is a directory that corresponds to the group that our newly created display belongs to.  Any display with group <code>&quot;exploratory&quot;</code> will be put here.</p>

<pre><code class="r"># list the files in the &quot;exploratory&quot; group
list.files(file.path(vdbDir, &quot;displays&quot;, &quot;exploratory&quot;))
</code></pre>

<pre><code>[1] &quot;tracks_byflight&quot;
</code></pre>

<p>We see a directory for our display, <code>tracks_byflight</code> in here.  Let&#39;s see what is in this directory:</p>

<pre><code class="r"># look at files in the &quot;tracks_byflight&quot; directory
list.files(file.path(vdbDir, &quot;displays&quot;, &quot;exploratory&quot;, &quot;tracks_byflight&quot;))
</code></pre>

<pre><code>[1] &quot;displayObj.Rdata&quot; &quot;thumb.png&quot;       
</code></pre>

<p>There are two files:</p>

<ul>
<li><code>displayObj.Rdata</code> is an R data object with all of the parameters that went in to creating the display</li>
<li><code>thumb.png</code> is the rendered display</li>
</ul>

<p>For Trelliscope displays, <code>thumb.png</code> is the rendering of one subset of the data.  There will also be a subdirectory, <code>panels</code>, which is a directory either containing the data against which the display is applied, or a collection of rendered panels.</p>

<h4>Listing all displays</h4>

<p>To see what displays have been created in a VDB, we can do the following:</p>

<pre><code class="r"># list all displays in the VDB
listDisplays()
</code></pre>

<pre><code>           name |       group |                    desc | n |     dataClass
----------------+-------------+-------------------------+---+--------------
tracks_byflight | exploratory | The tracks of the ai... | 1 | none (R plot)
</code></pre>

<p>This provides some simple information about each display in the VDB.  The column <code>n</code> is the number of panels in the display, and the column <code>dataClass</code> indicates the connection type of the data from which the display was created (used for Trelliscope displays).</p>

<!-- For more specific information about a display -->

<h4>Viewing displays</h4>

<p>We can view a display with the following:</p>

<pre><code class="r"># view the tracks_by_flight display
view(&quot;tracks_byflight&quot;)
</code></pre>

<p>There is a much more interesting viewer for Trelliscope displays.</p>

<h4>Removing displays</h4>

<p>It is possible to overwrite a display, in which case the directory of the display being replaced is renamed with a <code>&quot;_bak&quot;</code> appended to its name.  </p>

<p>However, we may want to completely remove a display from our VDB.  We can do this with:</p>

<pre><code class="r">removeDisplay(&quot;tracks_byflight&quot;)
</code></pre>

<p>While a display is uniquely identified by its name and group, we can get away with just specifying a name if it is unique.</p>

</div>


<div class='tab-pane' id='division-with-datadr'>
<h3>Division with datadr</h3>

<p>Trelliscope is an extension of Trellis Display that allows you to create displays with potentially thousands to millions of panels.  It provides a mechanism to create and interact with these displays.</p>

<p>Conditioning in Trelliscope is achieved by dividing the data into subsets, one subset for each panel.  Trelliscope uses the division mechanism of the Divide &amp; Recombine (D&amp;R) package, <code>datadr</code>.  It is assumed that you have already gone through the <code>datadr</code> <a href="http://hafen.github.io/datadr">tutorial</a>.  Essentially, Trelliscope provides <em>visual recombination</em> methods for D&amp;R.</p>

<h4>Geographical division of airplane data</h4>

<p>There are many ways we might want to split the data, depending on the purpose of our analysis.  One aspect of the <code>airplane</code> data that we are interested in is how different variables, such as <code>co</code> change over the course of a day in different geographical locations.  </p>

<p>Looking at our previous plots of the airplane tracks, we notice that within each square defined by the grid lines the airplane recovers many of its tracks from AM to PM:</p>

<p><img src="figures/knitr/ap_tracks2.png" alt="plot of chunk ap_tracks2"> </p>

<p>Thus, it might be interesting to split the data into subsets by cutting the latitude and longitude into small squares (okay, so these aren&#39;t really <em>squares</em>), and then study the variables of interest within those squares.  We can do this with the following:</p>

<pre><code class="r"># latitude and longitude &quot;square&quot; boundaries
latCuts &lt;- seq(38.2, 39.4, by=0.1)
lonCuts &lt;- seq(-121.8, -120.8, by=0.1)

# divide the data by lat / lon
byLatLon &lt;- divide(airplane, by=c(&quot;latCut&quot;, &quot;lonCut&quot;),
   preTransFn = function(x) {
      x$latCut &lt;- cut(x$latitude, latCuts)
      x$lonCut &lt;- cut(x$longitude, lonCuts)
      x
   },
   update=TRUE)
</code></pre>

<p>Note that with this small dataset, we could have appended the <code>latCuts</code> and <code>lonCuts</code> variables to the <code>airplane</code> data frame prior to calling <code>divide()</code>.</p>

<p>Let&#39;s look at the resulting distributed data frame (&quot;ddf&quot;) object:</p>

<pre><code class="r"># look at the resulting object
byLatLon
</code></pre>

<pre><code>
Distributed data object of class &#39;kvMemory&#39; with attributes: 

&#39;ddo&#39; attribute | value
----------------+-----------------------------------------------------------
 keys           | keys are available through getKeys(dat)
 totStorageSize | 1007.05 KB
 totObjectSize  | 1007.05 KB
 nDiv           | 54
 splitSizeDistn | use splitSizeDistn(dat) to get distribution
 example        | use kvExample(dat) to get an example subset
 bsvInfo        | [empty] no BSVs have been specified

&#39;ddf&#39; attribute | value
----------------+-----------------------------------------------------------
 vars           | dat_ams(POS), org(POS), NO3(num), SO4(num), and 46 more
 transFn        | identity (original data is a data frame)
 nRow           | 1479
 splitRowDistn  | use splitRowDistn(dat) to get distribution
 summary        | use summary(dat) to see summaries

Division:
  Type: Conditioning variable division
    Conditioning variables: latCut, lonCut

In-memory data connection
</code></pre>

<p>Also, let&#39;s look at a key-value pair to make sure it looks how we think it should:</p>

<pre><code class="r"># see what a subset key-value pair looks like
str(byLatLon[[1]])
</code></pre>

<pre><code>List of 2
 $ : chr &quot;latCut=(38.3,38.4]|lonCut=(-121.3,-121.2]&quot;
 $ :Classes &#39;divValue&#39; and &#39;data.frame&#39;:    4 obs. of  50 variables:
  ..$ dat_ams    : POSIXct[1:4], format: &quot;2010-06-28 18:19:35&quot; ...
  ..$ org        : num [1:4] 13.3 13.3 13.3 15.2
  ..$ NO3        : num [1:4] 0.84 0.826 0.715 1.12
  ..$ SO4        : num [1:4] 0.72 0.642 0.679 0.905
  ..$ NH4        : num [1:4] 0.372 0.365 0.336 0.454
  ..$ CHL        : num [1:4] 0.00905 0.03785 0.0131 0.02075
  ..$ org_err    : num [1:4] 0.121 0.122 0.122 0.124
  ..$ NO3_err    : num [1:4] 0.02 0.0197 0.0192 0.0215
  ..$ SO4_err    : num [1:4] 0.0338 0.0328 0.0327 0.0339
  ..$ NH4_err    : num [1:4] 0.0363 0.0363 0.0364 0.0366
  ..$ CHl_err    : num [1:4] 0.0125 0.0123 0.0122 0.0122
  ..$ latitude   : num [1:4] 38.4 38.4 38.4 38.4
  ..$ longitude  : num [1:4] -121 -121 -121 -121
  ..$ altitude   : num [1:4] 364 377 400 379
  ..$ static_p   : num [1:4] 966 965 962 965
  ..$ altitude_p : num [1:4] 339 351 373 352
  ..$ static_t   : num [1:4] 28.4 28.1 27.9 28.4
  ..$ potential_t: num [1:4] 31.4 31.1 31.2 31.5
  ..$ dewpt      : num [1:4] 14.2 14.5 15.6 15.3
  ..$ RH         : num [1:4] 42.1 43.6 47.2 45.2
  ..$ h2o_MF     : num [1:4] 10.6 10.8 11.7 11.4
  ..$ windspd    : num [1:4] 1.25 1.3 0.4 1.01
  ..$ winddir    : num [1:4] 311.3 331.2 13.6 318.7
  ..$ cpc_3025   : num [1:4] 50563 33147 58963 62464
  ..$ cpc_3010   : num [1:4] 3500 2350 4369 4606
  ..$ ozone      : num [1:4] 50.5 53.6 60 60.4
  ..$ co         : num [1:4] 154 149 NA NA
  ..$ so2        : num [1:4] 2.73 1.99 2.98 3.18
  ..$ no         : num [1:4] 0.383 0.303 NA NA
  ..$ no2        : num [1:4] 2.2 1.23 NA NA
  ..$ noy        : num [1:4] 7.45 6.94 NA NA
  ..$ mz_33      : num [1:4] 16.6 14.6 14.3 16
  ..$ mz_42      : num [1:4] 0.0636 -0.0207 0.076 0.0786
  ..$ mz_45      : num [1:4] 4.7 3.99 4.43 4.14
  ..$ mz_59      : num [1:4] 5.58 5.36 6.3 6.07
  ..$ mz_69      : num [1:4] 0.356 0.636 0.527 0.358
  ..$ mz_71      : num [1:4] 1.26 1.33 1.05 1.12
  ..$ mz_79      : num [1:4] 0.09247 0.00985 0.21491 0.08101
  ..$ mz_93      : num [1:4] 0.24394 0.00496 0.19109 0.17658
  ..$ mz_107     : num [1:4] 0.221 0.284 0.413 0.467
  ..$ mz_137     : num [1:4] 0.22955 0.19211 0.19416 0.00166
  ..$ mz_43      : num [1:4] 4.95 4.15 4.56 4.36
  ..$ mz_61      : num [1:4] 2.94 2.91 2.95 2.7
  ..$ mz_87      : num [1:4] 0.396 0.283 0.272 0.374
  ..$ mz69_71    : num [1:4] 1.62 1.97 1.58 1.48
  ..$ leg_flag   : int [1:4] 6 6 6 6
  ..$ nox        : num [1:4] 2.58 1.54 NA NA
  ..$ flight     : chr [1:4] &quot;am&quot; &quot;am&quot; &quot;am&quot; &quot;am&quot;
  ..$ altCut     : chr [1:4] &quot;(0,500]&quot; &quot;(0,500]&quot; &quot;(0,500]&quot; &quot;(0,500]&quot;
  ..$ datCut     : chr [1:4] &quot;06-28/18:15&quot; &quot;06-28/18:15&quot; &quot;06-28/18:15&quot; &quot;06-28/18:15&quot;
  ..- attr(*, &quot;split&quot;)=&#39;data.frame&#39;:    1 obs. of  2 variables:
  .. ..$ latCut: chr &quot;(38.3,38.4]&quot;
  .. ..$ lonCut: chr &quot;(-121.3,-121.2]&quot;
</code></pre>

<p>We have our division.  Now we are ready to make some displays.</p>

</div>


<div class='tab-pane' id='a-bare-bones-display'>
<h3>A Bare Bones Display</h3>

<p>To quickly get our feet wet with creating a display, we start with a minimal example.  Creating a plot first requires the specification of what you would like to be plotted for each subset.  Just like with <code>lattice</code>, you create a panel function that will be applied to each subset.  The function is applied to each key-value pair subset in your data.  This function behaves like all other per-subset functions in <code>datadr</code>, which can operate either on both a key and a value of just the value (see <a href="http://hafen.github.io/datadr/#key-value-pairs">here</a> for more details).</p>

<p>Some things to know about the panel function:</p>

<ul>
<li>The panel function is applied to each subset of your divided data object</li>
<li>The panel function returns something that can be printed to a graphics device</li>
<li>Those familiar with lattice can think of the panel function as the lattice panel function and the data argument(s) as the lattice packet being plotted (except that you conveniently get the whole data structure instead of just <code>x</code> and <code>y</code>)</li>
<li>As long as the plotting method you use can produce graphics in a graphics device, you can use it: base R graphics, lattice, or ggplot2 are all available </li>
<li>However, using something like lattice or ggplot2 adds benefit because these create objects which can be inspected to pull out axis limits, etc. (see our discussion of <code>prepanel</code> functions later on)</li>
<li>If you use something that doesn&#39;t create an object (such as base R graphics), you need to wrap the list of plot commands in an expression as the return value</li>
<li>In the future, I will provide support for custom rendering hooks/methods to accommodate more plotting options</li>
</ul>

<h4>Panel function for <code>co</code> vs. time</h4>

<p>Suppose we want to do a simple time series plot of the log of <code>co</code> vs. time for each geographical block, and we want to add a fitted line to the data.  Using <code>lattice</code> to create the panel function, we can do this with the following:</p>

<pre><code class="r"># a simple panel function for a trelliscope display
coPanelFn &lt;- function(d) {
   xyplot(log2(co) ~ dat_ams, data=d, 
      type=c(&quot;p&quot;, &quot;g&quot;),
      panel=function(x, y, ...) {
         panel.xyplot(x, y, ...)
         try(panel.lmline(x, y, lty=2), silent=TRUE)
      })
}
</code></pre>

<p>The argument <code>d</code> (you can call it whatever you like) is the value of one of the subsets of your divided data set.  Let&#39;s test it on a subset of our data:</p>

<pre><code class="r"># apply the panel function to a subset
kvApply(coPanelFn, byLatLon[[2]])
</code></pre>

<p><img src="figures/knitr/simple_co_apply.png" alt="plot of chunk simple_co_apply"> </p>

<h4>Making the display</h4>

<p>To create a display, applying this panel function over the entire data set, we simply call <code>makeDisplay()</code>:</p>

<pre><code class="r"># create a simple display
makeDisplay(byLatLon,
   panelFn = coPanelFn,
   name    = &quot;co_vs_time_bb&quot;,
   group   = &quot;co&quot;,
   desc    = &quot;Bare bones display of co vs. time for each geographic &#39;square&#39; with fitted linear model&quot;
)
</code></pre>

<p>The two most important arguments are the first argument, <code>data</code>, and the panel function, <code>panelFn</code>.  The other arguments in this example simply identify the display, as we saw previously.  We will later see other arguments to <code>makeDisplay()</code> that provide additional useful functionality.</p>

<p>Here, we are putting the display in a group <code>&quot;co&quot;</code> since that is the variable we are currently studying.</p>

<h4>Viewing the display</h4>

<p>To view the display:</p>

<pre><code class="r"># open the Trelliscope viewer for the VDB
view()
</code></pre>

<p>This will bring up the Trelliscope viewer.  You will get a list of displays to choose from (at this point, just one).  </p>

<!--If you aren't following along with the example in your own R console, you can look at the display on RStudio's glimmer site [here](http://glimmer.rstudio.com/rhafen/vdbexample2/#group=co&name=co_vs_time_plain).-->

<p>Later we will cover how to sync a local VDB with a web server.</p>

<p>You can also launch the viewer to go directly to this display with either of the following:</p>

<pre><code class="r"># open this display in the Trelliscope viewer
view(group=&quot;co&quot;, name=&quot;co_vs_time_bb&quot;)
view(name=&quot;co_vs_time_bb&quot;)
</code></pre>

<p>Notice that the second one works, even though a display is uniquely identified by the group and name combination.  Usually, name is unique too and if that is the case, group is inferred.</p>

<p>We&#39;ll talk more about how to use the viewer later, but feel free to play around.</p>

<p>Now, let&#39;s do something that shows all of the other functionality of <code>makeDisplay()</code>, including prepanel functions, cognostics, etc.</p>

</div>


<div class='tab-pane' id='axis-limits'>
<h3>Axis Limits</h3>

<p>As we discussed <a href="#trellis-display">before</a>, scales and axis limits are very important for creating meaningful Trellis displays.  In Trellis Display, axis limits can be computed by specifying the x and y axes as &quot;free&quot;, &quot;sliced&quot;, or &quot;same&quot;.  Based on the specification, each subset is checked against what is being plotted, and the axis limits are computed.  The same can be done for Trelliscope displays.  There are different ways to do this that we will cover in this section.</p>

<p>In the display we just created, we see that the axis limits of the panels appear to be &quot;free&quot;.  This is different from the <code>lattice</code> default of axis limits across panels being &quot;same&quot;.  Since Trelliscope is very general -- any R plotting technology can potentially be used in a panel function -- the default is to not try to do anything with axis limits.</p>

<p>Note: the discussion in this section is constrained to two-dimensional panels (with x and y axes), which covers the vast majority of useful statistical visualization techniques.  If you have panel functions that produce plots that do not fit this (e.g. pie charts -- no!!), then the functionality described in this section is not useful.</p>

<h4>Simple axis limits example</h4>

<pre><code class="r"># setting axis limits in the call to makeDisplay()
makeDisplay(byLatLon,
   name    = &quot;co_vs_time_same&quot;,
   group   = &quot;co&quot;,
   desc    = &quot;Plot of co vs. time for each geographic &#39;square&#39; with with fitted line, illustrating the use of &#39;same&#39; axis limits for x and y&quot;,
   panelFn = coPanelFn,
   lims    = list(x=&quot;same&quot;, y=&quot;same&quot;)
)
</code></pre>

<pre><code>* Attempting to create directory ... ok
* Saving connection attributes
* Directory is empty - use addData() to add k/v pairs to this directory
* Validating &#39;panelFn&#39;...
* Testing cognostics function on a subset ... ok
* Validating plot dimensions...
* Precomputed limits not supplied.  Computing axis limits...
Testing &#39;prepanelFn&#39; on a subset...
Using &#39;trellis&#39; panelFn to determine limits... dx and dy will not be computed.
* Getting basic &#39;ddo&#39; attributes...
At least one of the variables is not numeric.  Casting as numeric for quantile calculation purposes.
* Getting basic &#39;ddo&#39; attributes...
* Updating displayList...
* Storing display object...
* Plotting thumbnail...
</code></pre>

<p>This approach only works with <code>lattice</code> and <code>ggplot2</code> panel functions.  Per-panel axis limits are precomputed using the panel function and these are incorporated into the axis limits calculation to be applied to all panels.  The reason we are constrained to <code>lattice</code> and <code>ggplot2</code> is that Trelliscope needs to know the limits of what is being plotted in each panel to determine the overall axis limits, and these can be easily extracted from the resulting object after applying the panel function to a subset.</p>

<p>Here is an example of this display, using <code>ggplot2</code>:</p>

<pre><code class="r"># same display but using ggplot2
ggCoPanelFn &lt;- function(x) {
   qplot(dat_ams, log2(co), data=x)
}

makeDisplay(byLatLon,
   name    = &quot;co_vs_time_gg&quot;,
   group   = &quot;co&quot;,
   desc    = &quot;Plot of co vs. time for each geographic &#39;square&#39; with with fitted line, illustrating the use of &#39;same&#39; axis limits for x and y, and using ggplot2&quot;,   
   panelFn = ggCoPanelFn,
   lims    = list(x=&quot;same&quot;, y=&quot;same&quot;)
)
</code></pre>

<pre><code>Warning: Removed 7 rows containing missing values (geom_point).
</code></pre>

<p>Note: <code>ggplot2</code> support at the moment is pretty shaky.  For the general continuous axis scales, it should work fine, but more work needs to be done to integrate nicely.</p>

<h4>Specifying a prepanel function</h4>

<p>The previous example is the most simple way to specify axis limits.  However, it comes with a potential cost -- the panel function must be applied to each subset in order to obtain the limits.  For panel functions that take some time to render, this is wasted time.</p>

<p>As an alternative, we can explicitly supply a prepanel function to the <code>lims</code> argument list, called <code>prepanelFn</code>.  This functions in the same way as for <code>lattice</code>, where the prepanel function takes each subset of data and returns a list with <code>xlim</code> and <code>ylim</code>.  For example:</p>

<pre><code class="r"># using a prepanel function to compute axis limits
preFn &lt;- function(x) {
   list(ylim=range(log2(x$co)), xlim=range(x$dat_ams))
}

makeDisplay(byLatLon,
   name    = &quot;co_vs_time_pre&quot;,
   group   = &quot;co&quot;,
   desc    = &quot;Plot of co vs. time for each geographic &#39;square&#39; with with fitted line, illustrating the use of &#39;same&#39; axis limits for x and y using a prepanel function&quot;,
   panelFn = coPanelFn,
   lims    = list(x=&quot;same&quot;, y=&quot;same&quot; , prepanelFn=preFn)
)
</code></pre>

<h4>Determining limits beforehand with <code>prepanel()</code></h4>

<p>In both of the above approaches, we computed axis limits at the time of creating the display.  This is not recommended for very large datasets.  There are a few reasons for this.  </p>

<ol>
<li>Setting the axis limits based on &quot;sliced&quot; or &quot;same&quot; is not very robust to outliers, and we may wish to understand and modify the axis limits prior to creating the display.</li>
<li>Computing the axis limits can be more costly than creating a display, and it can be good to separate the two, particularly when we may be iterating on getting a panel function just right.</li>
</ol>

<p>We can use a function, <code>prepanel()</code>, to compute axis limits prior to creating a display.</p>

<p>The main parameter to know about in <code>prepanel()</code> is <code>prepanelFn</code>, which operates in the same way as we saw before -- it is either a <code>lattice</code> or <code>ggplot2</code> panel function or it is a function that takes a subset of the data as an input and returns a list including the elements <code>xlim</code> and <code>ylim</code> (each a vector of the min and max x and y ranges of the data subset).</p>

<pre><code class="r"># compute axis limits prior to creating display using prepanel()
coTimePre &lt;- prepanel(byLatLon, prepanelFn=coPanelFn)
</code></pre>

<h4>Determining axis limits from <code>prepanel()</code> output</h4>

<p>We can now determine our axis limits based on the results from <code>prepanel()</code>.  The output from <code>prepanel</code> is an object which has a plot method that can help in the decision of how to specify limits.</p>

<p>To view a plot of the panel axis limits to help in this determination:</p>

<pre><code class="r"># visualize the axis limit computations
plot(coTimePre)
</code></pre>

<pre><code>At least one of the variables is not numeric.  Casting as numeric for plotting purposes.
</code></pre>

<p><img src="figures/knitr/co_pre_plot.png" alt="plot of chunk co_pre_plot"> </p>

<p>This plot orders the axis limits for both the x and y axes for both &quot;same&quot; and &quot;sliced&quot; (with sliced ranges centered around zero).  This can help us to see if we will be squeezing the data for a lot of panels when using &quot;same&quot;, and also helps identify outliers.  In each of the panels of this plot, you can think of the range of the &quot;Panel Limits&quot; axis as the range that will ultimately be chosen for each panel for the given axis and limit method.</p>

<p>For this plot, it appears that slicing the axis limits does not buy us much resolution, and we know that for the time variable axis (x), we would like the limits to always be the same.  Thus, we choose &quot;same&quot; for both axes.</p>

<p>To set our choice, we do the following:</p>

<pre><code class="r"># set limits from our prepanel calculations
coTimeLims &lt;- setLims(coTimePre) # default is x=&quot;same&quot;, y=&quot;same&quot;
</code></pre>

<p><code>makeDisplay()</code> can take this object as is argument for <code>lims</code> and will set panel limits accordingly.</p>

<pre><code class="r"># create a display using axis limits from prepanel() and setLims()
makeDisplay(byLatLon,
   name    = &quot;co_vs_time_lims&quot;,
   group   = &quot;co&quot;,
   desc    = &quot;Plot of co vs. time for each geographic &#39;square&#39; with with fitted line, illustrating the use of &#39;same&#39; axis limits for x and y by pre-specifying the axis limits using prepanel() and setLims()&quot;,
   panelFn = coPanelFn,
   lims    = coTimeLims
)
</code></pre>

<!-- #### Setting the limits manually

You can also explicitly specify limits with `lims` in `makeDisplay()`, which will automatically perform the axis limit computations prior to creating the display. -->

<h4>Setting the limits in your panel function</h4>

<p>Another option, of course, is to set axis limits explicitly in your panel function.</p>

<!-- This really isn't very much work for the benefit we receive from what we are able to do with the display after it's created. -->

<!-- Currently, this is how aspect ratios of the bounding boxes are specified.  There is functionality for you to specify an aspect ratio and either a height or a width, where the bounding box with which the panel aspect ratio is computed is based on the data, not the entire plot (including axis labels, etc.), but it isn't quite working.  You can specify aspect ratios in your lattice plots, but it is then difficult to get the panel dimensions correct such that there is not a lot of white space wasted for each panel (remember, we want to tile many of these across one screen so we don't want to waste white space).  On a related note, for lattice plots, see `?noMargins`. -->

</div>


<div class='tab-pane' id='cognostics'>
<h3>Cognostics</h3>

<p>Much of the power of the viewer for multi-panel displays (particularly when the panels number in the thousands or higher) lies in the ability to specify metrics that provide interesting information about each panel, with which you can filter and sort your collection of panels to look for those which are interesting.  John Tukey called a notion similar to this &quot;cognostics&quot;.</p>

<p>We can obtain cognostics for our panels by specifying a <code>cogFn</code> function to <code>makeDisplay()</code>.</p>

<p>The cognostics function is applied to each subset just like the panel function and must return a list which can be flattened into a data frame.  For our geographically split data, there are several cognostics we might be interested in.  Typically the most useful cognostics are arrived upon iteratively.  Here, we specify the number of observations in the subset, the slope of a fitted line to <code>co</code> vs. time, the mean latitude and longitude, and the range of the time variable.</p>

<pre><code class="r"># create a cognostics function to be applied to each subset
coCogFn &lt;- function(x) {
   slp &lt;- coef(lm(co ~ as.integer(dat_ams), data=x))[2]
   if(is.na(slp))
      slp &lt;- 0
   list(
      nobs = cog(length(which(!is.na(x$co))), desc=&quot;number of observations&quot;),
      slope = cog(slp, desc=&quot;slope of fitted line&quot;),
      meanLat = cogMean(x$latitude, desc=&quot;mean latitude&quot;),
      meanLon = cogMean(x$longitude, desc=&quot;mean longitude&quot;),
      timeRange = cogRange(as.integer(x$dat_ams[!is.na(x$co)]) / 60^2, desc=&quot;Time range (hours)&quot;)
   )
}
</code></pre>

<p>The helper functions <code>cog()</code>, <code>cogMean()</code>, <code>cogRange()</code>, etc. can be used when defining the cognostics list.  The most generic, <code>cog()</code> basically wraps the metric you want to compute with additional information, such as the description of the cognostic.  They are not necessary but are helpful.  For example, the difference between <code>cogRange()</code> and <code>range()</code> and others is that there is removal of NAs and extra checking for errors so that the cognostic calculation is robust.</p>

<p>Note that if you don&#39;t want to wrap your calculations in <code>cog()</code>, you don&#39;t have to, but doing so allows you to control the type of variable and give it a description.</p>

<!-- Current types are:
- `int `: integer 
- `num `: floating point
- `fac `: factor (string)
- `date`: date
- `time`: datetime
- `geo `: geographic (a vector of lat and lon)
- `rel `: relation (not implemented)
- `hier`: hierarchy (not implemented)

If type is not specified, it is inferred based on the data being processed.

In the future, support for input variables will be added (this existed in older versions).  These will not be computed based on the data, but will be placeholders for users to provide panel-specific input. -->

<p>Let&#39;s test the cognostics function on a subset:</p>

<pre><code class="r"># test the cognostics function on a subset
kvApply(coCogFn, byLatLon[[1]])
</code></pre>

<pre><code>$nobs
[1] 2

$slope
[1] 0

$meanLat
[1] 38.38

$meanLon
[1] -121.3

$timeRange
[1] 0.003611
</code></pre>

<p>Now, let&#39;s add these cognostics to our display:</p>

<pre><code class="r"># add cognostics to the display
makeDisplay(byLatLon,
   name    = &quot;co_vs_time&quot;,
   group   = &quot;co&quot;,
   desc    = &quot;Plot of co vs. time for each geographic &#39;square&#39; with with fitted line, illustrating the use of &#39;same&#39; axis limits and a cognostics function&quot;,
   panelFn = coPanelFn,
   cogFn   = coCogFn,
   lims    = coTimeLims
)
</code></pre>

<!--This display can be viewed [here](http://glimmer.rstudio.com/rhafen/vdbexample/#group=co&name=co_vs_time).-->

<p>With this display, we can start to see the utility of cognostics.  Pressing the &quot;cog&quot; button in the viewer brings up a table of cognostics with ways to sort and filter the panels based on the values of the cognostics.  This is particularly useful when there are more panels than you could possibly view.</p>

</div>


<div class='tab-pane' id='panel-storage'>
<h3>Panel Storage</h3>

<p>The default behavior for how panels are stored is to store the data subsets and then render the panels on-the-fly in the viewer.  </p>

<p>When we are not pre-rendering, if the input data is already a persistent divided data object, then that data object is simply used as the input when rendering is done by the viewer on-the-fly.  For example, if we have a very large data set on HDFS with a very large number of subsets, we can simply specify the HDFS connection as the input, and the only computation that needs to be done is the prepanel of cognostics computations, if specified.</p>

<p>When we are pre-rendering, the panels are rendered at the time <code>makeDisplay()</code> is called and the output is stored somewhere, which can be on any valid <code>datadr</code> storage backend such as local disk or HDFS.  The default is local disk in the display&#39;s VDB directory.</p>

<p>For the examples we have seen so far, our input has been an in-memory divided data object, which is not persistent.  By default, Trelliscope takes such input and stores it as to &quot;localDiskConn&quot; connection in the <code>&quot;panels&quot;</code> subdirectory of the display&#39;s directory in the VDB.  If we were to pre-render, the data would still go to this location, but instead of being the input data, it will be the rendered panel images.</p>

<h4>When to pre-render</h4>

<p>There are trade-offs for pre-rendering or not:</p>

<p><strong>In favor of pre-rendering</strong></p>

<ul>
<li>Paging through panels can be faster as we don&#39;t have to render them prior to displaying them</li>
<li>Less work for the web server</li>
</ul>

<p><strong>In favor of rendering on-the-fly</strong></p>

<ul>
<li><code>makeDisplay()</code> is considerably faster - we only need to compute cognostics and metadata about the display.  This is particularly true for very large datasets.</li>
<li>If we are only ever going to view a small subset of possibly hundreds of thousands of panels, why render them all up-front instead of rendering the ones you currently want to look at?</li>
<li>Image resolution: we do now know if the image will be viewed as a single large panel in the window, or tiled with tens or hundreds of panels in a single window.  When we render the image on-the-fly, we can render it at the resolution at which it will be viewed instead of having to store a raster image that has a resolution sufficient to be viewed at the largest scale.  A way around this would be to go away from .png to a vector format like .svg.  The only problem with that is that those files can get very large, and can be difficult to render consistently across all browsers.  In the future, this may all move toward using something like d3 as the rendering engine.</li>
</ul>

<h4>Pre-rendering example</h4>

<p>Here is an example of how to specify pre-rendering when creating a display:</p>

<pre><code class="r"># make display with panels pre-rendered
makeDisplay(byLatLon,
   name      = &quot;co_vs_time_rend&quot;,
   group     = &quot;co&quot;,
   desc      = &quot;Plot of co vs. time for each geographic &#39;square&#39; with with fitted line, illustrating the use of &#39;same&#39; axis limits and a cognostics function, and pre-rendered panels&quot;,
   panelFn   = coPanelFn,
   cogFn     = coCogFn,
   lims      = coTimeLims,
   preRender = TRUE
)
</code></pre>

<p>The only thing that changes is that we specify <code>preRender=TRUE</code>.  Now, the data stored as the output for this display are a binary png blob for each panel.</p>

</div>


<div class='tab-pane' id='cognostics-storage'>
<h3>Cognostics Storage</h3>

<p>The default behavior for storing cognostics is as an R data frame.  This provides convenience in computations regarding cognostics in the viewer, but is limiting from a scalability point of view, as it will become difficult to manage with the number of panels beyond the hundreds of thousands.  There is now experimental support for storing cognostics in a MongoDB collection.  In this case, it should be possible to handle a much larger number of panels.</p>

<p>To store cognostics in MongoDB, we must first initiate a cognostics MongoDB connection.  This of course requires a MongoDB instance to be running somewhere that you have access to - the following code will only work if this is the case.</p>

<pre><code class="r"># initiate a MongoDB cognostics connection
mongoConn &lt;- mongoCogConn()   
</code></pre>

<p>In <code>mongoCogConn()</code>, you can specify information such as the host address, etc. of MongoDB.  The parameters and their defaults can be seen with<code>?mongoCogConn</code>.</p>

<p>Now, we can simply specify this as the <code>cogConn</code> argument in our call to <code>makeDisplay()</code> and cognostics will be stored in this connection.</p>

<pre><code class="r"># create the display using MongoDB to store the cognostics
makeDisplay(byLatLon,
   name      = &quot;co_vs_time_mon&quot;,
   group     = &quot;co&quot;,
   desc      = &quot;Plot of co vs. time for each geographic &#39;square&#39; with with fitted line, illustrating the use of &#39;same&#39; axis limits and a cognostics function, and storing cognostics in MongoDB&quot;,
   panelFn   = coPanelFn,
   cogFn     = coCogFn,
   cogConn   = mongoConn,
   lims      = coTimeLims
)
</code></pre>

<p>When this display is being viewed, the MongoDB database will be queried as we interact with the panels of the display.</p>

<p>We chose MongoDB as a potential cognostics storage backend simply because it provides a scalable database, allows for indexing, and has a flexible aggregation framework.  The Trelliscope cognostics connection interface is extendable, such that other cognostic storage backends could be explored as well.</p>

</div>


<div class='tab-pane' id='linking-displays'>
<h3>Linking Displays</h3>

<p>We typically have many different ways to look at the same division of data.  When creating a display against a divided dataset, Trelliscope keeps track of the division of the input data, and all displays created on the same division can be linked together in the Trelliscope viewer.</p>

<p>To illustrate this, here we create a display with a panel function that, for each geographical subset, simply shows all of the airplane&#39;s tracks on the grid, with the grid location of the current subset highlighted in gray.  We will see how this display can be useful when being viewed in conjunction with other displays in the <a href="#shiny-viewer">following section</a>.</p>

<pre><code class="r"># panel function for a geographical display
latLonPanelFn &lt;- function(a) {
   yy &lt;- as.numeric(strsplit(gsub(&quot;\\(|\\]&quot;, &quot;&quot;, attr(a, &quot;split&quot;)$latCut), &quot;,&quot;)[[1]])
   xx &lt;- as.numeric(strsplit(gsub(&quot;\\(|\\]&quot;, &quot;&quot;, attr(a, &quot;split&quot;)$lonCut), &quot;,&quot;)[[1]])

   xyplot(airplane$latitude ~ airplane$longitude,
      groups=airplane$dat_ams &lt; as.POSIXct(&quot;2010-06-28 21:00:00 UTC&quot;),
      panel=function(x, y, ...) {
         panel.rect(xx[1], yy[1], xx[2], yy[2], col=&quot;darkgray&quot;)
         panel.abline(v=lonCuts, col=&quot;gray&quot;)
         panel.abline(h=latCuts, col=&quot;gray&quot;)
         panel.xyplot(x, y, ...)
      }
   )
}

# test the panel function on a subset
kvApply(latLonPanelFn, byLatLon[[2]])
</code></pre>

<p><img src="figures/knitr/lat_lon_display.png" alt="plot of chunk lat_lon_display"> </p>

<pre><code class="r"># create the display
makeDisplay(
   data = byLatLon,
   name = &quot;lat_vs_lon&quot;,
   group = &quot;co&quot;,
   desc = &quot;airplane tracks&quot;,
   panelFn = latLonPanelFn
)
</code></pre>

<p>Note that the panel function uses data objects <code>lonCuts</code> and <code>latCuts</code>, data objects that are only visible in our local environment.  <code>makeDisplay()</code> checks the panel and cognostics functions to detect locally stored data and attaches it to the display object so it will be available at the time of rendering.</p>

</div>


<div class='tab-pane' id='scatterplot-displays'>
<h3>Scatterplot Displays</h3>

<p>Scatterplot matrices become increasingly infeasible as the number of variables grows beyond \(\approx\)10.  Using <code>trelliscope</code>, we can create &quot;scatterplot displays&quot;, where for \(p\) variables we create a panel for each of the \(\tbinom{p}{2}\) pairwise combinations.  We can leverage research on &quot;scagnostics&quot; (scatterplot diagnostics, or cognostics for scatterplots) <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=leland%20wilkinson%20scagnostics&amp;source=web&amp;cd=1&amp;ved=0CDIQFjAA&amp;url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.62.6148%26rep%3Drep1%26type%3Dpdf&amp;ei=6spVUcCQDYWl4AOJ_oHoDw&amp;usg=AFQjCNH0rmXCgq5vR-mEkuYz8AC476e6Bw&amp;sig2=VipicfJ0CN0AOJ4pt_yuXg&amp;bvm=bv.44442042,d.dmg&amp;cad=rja)">reference</a>, which includes the R package <a href="http://cran.r-project.org/web/packages/scagnostics/">scagnostics</a> to identify interesting relationships.  I have created a convenience function for doing this, <code>splod()</code> (<strong>s</strong>catter<strong>plo</strong>t <strong>d</strong>isplay).  This function takes a data frame and creates a subset for the data for each pairwise combination of variables.  The panel function is a simple scatterplot, and the cognostics function is a collection of scagnostics.</p>

<p>To illustrate this, we can create a scatterplot display for all of the variables in the <code>airplane</code> data.  First, we call <code>makeSplodDat()</code> to get the data into the correct format:</p>

<pre><code class="r"># create data for scatterplot display
airplaneSplodDat &lt;- makeSplodData(airplane, 
   id.vars=c(&quot;dat_ams&quot;, &quot;flight&quot;, &quot;datCut&quot;))
</code></pre>

<p>This creates all pairwise groupings of variables not found in <code>id.vars</code> and puts them into a &quot;ddf&quot; object.  </p>

<p>Here&#39;s an example of what a subset looks like:</p>

<pre><code class="r"># look at a subset of airplaneSplotDat
str(kvExample(airplaneSplodDat))
</code></pre>

<pre><code>List of 2
 $ : chr &quot;xVar=NO3|yVar=org&quot;
 $ :&#39;data.frame&#39;:   1479 obs. of  6 variables:
  ..$ x      : num [1:1479] 0.449 0.589 0.536 0.57 0.457 ...
  ..$ y      : num [1:1479] 9.26 13.29 12.13 12.36 10.11 ...
  ..$ dat_ams: POSIXct[1:1479], format: &quot;2010-06-28 16:25:21&quot; ...
  ..$ flight : chr [1:1479] &quot;am&quot; &quot;am&quot; &quot;am&quot; &quot;am&quot; ...
  ..$ altCut : Factor w/ 6 levels &quot;(0,500]&quot;,&quot;(500,1e+03]&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
  ..$ datCut : chr [1:1479] &quot;06-28/16:15&quot; &quot;06-28/16:15&quot; &quot;06-28/16:15&quot; &quot;06-28/16:15&quot; ...
  ..- attr(*, &quot;split&quot;)=List of 2
  .. ..$ xVar: chr &quot;NO3&quot;
  .. ..$ yVar: chr &quot;org&quot;
</code></pre>

<p>We can now create a display for this with <code>splod()</code>:</p>

<pre><code class="r">splod(airplaneSplodDat)
</code></pre>

<p>This passes <code>airplaneSplodDat</code> to <code>makeDisplay()</code>, with the default name being the same as the name of the data passed in concatenated with &quot;_splod&quot;, a default description of &quot;Scatterplot display&quot;, a cognostics function that computes several scagnostics (see <code>cogScagnostics()</code>), and a default plotting function that simply plots one variable vs. another.  You can override these and pass additional parameters to makeDisplay such as a custom cognostics function.</p>

<!-- ```{r airplane_splod, cache=TRUE}
splod(airplane, id.vars=c("dat_ams", "flight", "datCut"))
``` -->

</div>


<div class='tab-pane' id='shiny-viewer'>
<h3>Shiny Viewer</h3>

<p>The VDB viewer we have encountered throughout this document is a server-side web viewer that uses <a href="http://www.rstudio.com/shiny/">Shiny</a>.  Shiny basically provides a live R session running behind the web viewer, facilitating all of the interaction.</p>

<p>This viewer is a work in progress.  There are many possible features.  Focus is given first to functionality - I will work to optimize things once things settle.</p>

<p>Below I describe some of the components of the viewer.</p>

<h4>Panel View</h4>

<p>This is the main component of the viewer.  Once you have selected a display to view, the panel view tiles the panels of the chosen display and allows you to page through them.  Left and right keys or the buttons on the header bar page through panels.  The text box at the top of the window specifies (approximately) how many panels to tile across the screen (exact number is based on the aspect ratio of the panels).</p>

<h4>&quot;View&quot; Modal</h4>

<p>Click the &quot;view&quot; button.  You can specify which cognostics to display below each panel.  The second tab, &quot;plotFn&quot; will let you change the plot function applied to each subset (this only works when <code>storage</code> is &quot;localData&quot;<code>or</code>&quot;rhipeData&quot;`.</p>

<h4>&quot;Cognostics&quot; Modal</h4>

<p>Here, you can sort and filter the panels based on their cognostics.  Click the histograms to get an interactive histogram with which you can specify a range.  On the multivariate selection row, click and drag table cells to specify all variables you want to do multivariate filtering on.  If you choose 2 variables, you are given an interactive scatterplot on which you can select ranges to filter on.  If you select more than 2 variables, you get a bivariate view of a projection pursuit to filter on (actual filtering in this case doesn&#39;t work right now).  I need to give some more thought to making this interface optimal.  The load, save, reset filter settings don&#39;t work right now.  When you leave this modal, you go back to panel view with the panels arranged according to what you did in the cognostics panel.</p>

<h4>Changing the Display</h4>

<p>This is available as first menu item in the display button dropdown.  It simply brings up a modal that lets you select a different display to view.</p>

<h4>Adding a Related Display</h4>

<p>Displays with the same set of keys can have their panels displayed together.  (When a display is created, a hash is made of the sorted unique panel keys.  If two displays have the same hash, it means that they have the exact same collection of panel keys).</p>

<p>As an example, change the display to &quot;airTemp_vs_date&quot;.  Then select &quot;Add Related&quot; from the &quot;Display&quot; button dropdown and select &quot;lat_vs_lon&quot;.  Now you can view the movement of the buoy in association with the time series plots, and filter these to explore whether the lat/lon binning looks valid.</p>

<h4>Keyboard Shortcuts</h4>

<p>There are some keyboard shortcuts for convenience:</p>

<ul>
<li><strong>&quot;c&quot;</strong>: open cognostics modal</li>
<li><strong>&quot;v&quot;</strong>: open view modal</li>
<li><strong>&quot;d&quot;</strong>: open display modal</li>
<li><strong>&quot;r&quot;</strong>: open related displays modal</li>
<li><strong>esc</strong>: leave a modal and return to panel view</li>
</ul>

<!-- #### To Come

- A dropdown for each column (variable) in the cognostics table with options to:
  - apply a transformation to the variable
  - randomly sample displays to view across the distribution of this variable
  - if a continuous variable, discretize into bins
- A collapsible sidebar in the panel view that allows you to see where specified cognostics for the panels currently being viewed lie with respect those cognostics of all panels - either in a univariate or bivariate view
- Ability to specify panel-to-panel relationships within and between displays through cognostics, specified with something like `"group1/name1/key1;group2/name2/key2"`
- Add an interactive network graph using d3 for panel-to-panel relationships, used to select panels of interest
- Multi-user per-panel input / user "authentication"
- ... -->

</div>


<div class='tab-pane' id='cognostics-interactions'>
<h3>Cognostics Interactions</h3>

<p>The current viewer is a proof-of-concept, and I&#39;d like to see much more functionality here in the future.  In particular, the following are interactive filtering / sorting behaviors I would like to see for each cognostics type:</p>

<ul>
<li><strong>Numeric</strong>: filter / expore by univariate quantile plot / histogram - for groups of numeric variables, filter by scatterplot</li>
<li><strong>Factor (Categorical)</strong>: filter / explore by dropdown of categories, frequency bar chart, regular expression input</li>
<li><strong>Date/time</strong>: filter / explore by time window slider, time of day, day of week, calendar range, regular expression input</li>
<li><strong>Geo</strong>: filter / explore by lat/lon projected onto map</li>
<li><strong>Relation</strong>: specified by a list of keys pointing to other subsets (within same dataset or in others) - filter / explore by node groupings in a network graph which might be organized or colored by other cognostics variables</li>
<li><strong>Hierarchy</strong>: a label that is found in a hierarchy specified externally to the record (in a separate metadata file) - filter / explore by treemap, etc.</li>
</ul>

<p>Filters and interactivity based on combinations of cognostics would also be desirable, such as a numeric cognostic plotted versus a time cognostic as a time series, etc.</p>

<!-- ### Client-Side Viewer ###

There is a client-side viewer that is convenient because it does not require a web server, but is not nearly as flexible because it requires collections of plot files as the storage mechanism (instead of applying the plot function on the fly or storing the plots on HDFS or in MongoDB).  This viewer can be invoked by calling `view(type="cs")`.  It has not been maintained in a while. -->

</div>


<div class='tab-pane' id='creating-a-notebook'>
<h3>Creating a Notebook</h3>

<p>When collaborating with others or keeping track of your own research, it is not usually natural to have a bunch of displays lying around.  It is useful to organize them.  This package contains functions that help set up and maintain a web notebook that ties in to the vdb.</p>

<p>Notebooks are static pages, but are dynamically created using the <a href="http://yihui.name/knitr/">knitr</a> and <a href="http://cran.r-project.org/web/packages/markdown/index.html">markdown</a> packages.  I&#39;m not so concerned here about the &quot;reproducible research&quot; facets of knitr the package (difficult to deal with when your code depends on various backend systems that aren&#39;t always available, etc.), but they make things nice.  Mainly, the idea is that you can write a simple notebook using the simple <a href="http://daringfireball.net/projects/markdown/">markdown syntax</a> and not have to focus on layout, etc.  This of course comes with some lack of flexibility - a common tradeoff.</p>

<p>To create a new page, you can do the following:</p>

<pre><code class="r">newNotebook(title=&quot;Airplane data exploratory analysis&quot;)
</code></pre>

<pre><code>New notebook available for editing at /private/tmp/vdbtest/notebook/index.Rmd
</code></pre>

<p>There is also an argument, <code>name</code>, which determines the name of the <code>.Rmd</code> file generated.  The default is <code>&quot;index&quot;</code>, so that the new notebook page we set up has the name &quot;index.Rmd&quot; with the specified title and author.  If you recall from earlier, there is a <code>notebook</code> subdirectory in your VDB directory.  This is where the notebook files go.  Other options for <code>newNotebook()</code> include <code>toc</code> for whether you want a table of contents, and <code>css</code> if you would like to use a custom style sheet.</p>

<p>Let&#39;s look at the first few lines of the file we just created:</p>

<pre><code class="r">cat(paste(readLines(file.path(vdbDir, &quot;notebook&quot;, &quot;index.Rmd&quot;))[1:10], collapse=&quot;\n&quot;))
</code></pre>

<pre><code>```{r, echo=FALSE}
# do not remove this block - set parameters accordingly
bsSetup(
   pageTitle = "Airplane data exploratory analysis", 
   title     = "Airplane data exploratory analysis",
   author    = "Author Name",
   toc       = "TRUE",
   css       = NULL
)
```</code></pre>

<p>We see that there is a knitr R code block at the top that sets up the skeleton of the page using a function <code>bsSetup()</code>.  You can manually change options here to override what you initially specified when you called <code>newNotebook()</code> - (see the function reference for more details).  This first R code block sets up a skeleton of a web page with a header, optional sidebar with table of contents, etc.  Below this first code chunk in the .Rmd file is where you put your notebook text.  By default, the <code>newNotebook()</code> function creates some default content here that illustrates various aspects of markdown.</p>

<p>Go ahead and open this file in your favorite editor and try replacing the default content (leave the <code>bsSetup()</code> block in place) with the following:</p>

<pre><code># Initial exploratory plots

A list of displays from your VDB:

```{r echo=FALSE, results="asis"}
nbDisplayList(c("co_vs_time", "co_vs_time_gg", "lat_vs_lon"))
```

For a larger thumbnail for single-panel displays:

```{r echo=FALSE, results="asis"}
nbDisplay("tracks_byflight")
```</code></pre>

<p>The function <code>nbDisplay()</code> is a convenience function for embedding a display into your notebook.  It is typically good for single-panel displays.  The <code>nbDisplayList()</code> function takes a list of display names and creates a block of HTML that provides the thumbnail, name, and description about the display along with links for viewing the display.  </p>

<p>Now typeset it and view:</p>

<pre><code class="r">typeset() # or typeset(name=&quot;index&quot;)
viewNotebook() # or viewNotebook(name=&quot;index&quot;)
</code></pre>

<p>Note that &quot;index&quot; is the default page name but you can make pages with other names.</p>

</div>


<div class='tab-pane' id='syncing-files-with-the-web'>
<h3>Syncing Files With the Web</h3>

<p>Often our D&amp;R environment is on a local workstation which is connected to a distributed computing backend.  We might build up our VDB and web notebook locally and then desire to push the results to a web server which is running <a href="http://www.rstudio.com/shiny/server/">Shiny server</a>.  This is very useful for sharing analysis results with others.</p>

<p>There is some simple support for this in Trelliscope.  You can initialize a web connection using <code>webConn()</code>, which assumes that your web server is a Linux machine to which you have passwordless ssh capability.  You specify the address of the server, the directory of the VDB, and the name of the VDB under which you would like things stored.</p>

<pre><code class="r"># set up a web connection
wc &lt;- webConn(user=&quot;rhafen&quot;, ip=&quot;glimmer.rstudio.com&quot;, appDir=&quot;~/ShinyApps&quot;, name=&quot;vdbexample&quot;)
</code></pre>

<p>Now we can sync our VDB with the web:</p>

<pre><code class="r"># sync files with the web server
websync()
</code></pre>

</div>


<div class='tab-pane' id='scalable-system'>
<h3>Scalable System</h3>

<p>You can go through most of the examples we&#39;ve seen so far in this tutorial with a simple installation of R and the Trelliscope package and its R package dependencies.  </p>

<p>To deal with much larger datasets, scaling comes automatically with Trelliscope&#39;s dependency on <code>datadr</code> -- any backend supported by <code>datadr</code> is supported by Trelliscope.  These currently include Hadoop and local disk.</p>

<p>Some of the components beyond R that you will need to make use of these capabilities include:</p>

<ul>
<li><a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDH4/4.2.0/CDH4-Installation-Guide/CDH4-Installation-Guide.html">Hadoop</a></li>
<li><a href="http://www.datadr.org/install.html">RHIPE</a></li>
<li><a href="http://docs.mongodb.org/manual/tutorial/install-mongodb-on-red-hat-centos-or-fedora-linux/">MongoDB</a></li>
<li><a href="http://www.rstudio.com/shiny/server/">Shiny Server</a></li>
<li><a href="http://www.rstudio.com/ide/download/server">RStudio Server</a></li>
</ul>

<p>RStudio Server is not a necessary component, but is very convenient to put on the front-end node to the cluster.</p>

<h4>Using data on localDisk as input</h4>

<p>Here is a quick example of how to create a Trelliscope display using input data that is stored on local disk.</p>

<p>First, let&#39;s convert our in-memory <code>byLatLon</code> object to a &quot;localDiskConn&quot; object:</p>

<pre><code class="r"># convert byLatLon to a localDiskConn object
byLatLonLD &lt;- convert(byLatLon, 
   localDiskConn(&quot;/private/tmp/byLatLon&quot;, autoYes=TRUE))
</code></pre>

<p>Now, we simply specify this object as the input to <code>makeDisplay()</code>:</p>

<pre><code class="r"># make display using local disk connection as input
makeDisplay(byLatLonLD,
   name      = &quot;co_vs_time_ld&quot;,
   group     = &quot;co&quot;,
   desc      = &quot;Plot of co vs. time for each geographic &#39;square&#39; with with fitted line, illustrating the use of &#39;same&#39; axis limits and a cognostics function, with the data source being a local disk connection&quot;,
   panelFn   = coPanelFn,
   cogFn     = coCogFn,
   lims      = coTimeLims
)
</code></pre>

<p>The input connection is saved with the display object, and the data is used as the input when panels are rendered.  If we want to pre-render the panels, we can specify an argument <code>output</code>, which can be any <code>datadr</code> data connection.</p>

<h4>Using data on HDFS as storage and Hadoop/RHIPE as compute</h4>

<p>To illustrate creating a display with data on HDFS, we first convert <code>byLatLon</code> to an &quot;hdfsConn&quot; object:</p>

<pre><code class="r"># convert byLatLon to hdfsConn
byLatLonHDFS &lt;- convert(byLatLon, 
   hdfsConn(&quot;/tmp/byLatLon&quot;, autoYes=TRUE))
</code></pre>

<p>Since we will be pulling data at random by key from this object, we need to convert it to a Hadoop mapfile using <code>makeExtractable()</code> (<code>datadr</code> tries to make things mapfiles as much as possible, and <code>makeDisplay()</code> will check for this and let you know if your data does not comply).  </p>

<pre><code class="r"># make byLatLonHDFS subsets extractable by key
byLatLonHDFS &lt;- makeExtractable(byLatLonHDFS)
</code></pre>

<p>Now, to create the display:</p>

<pre><code class="r"># make display using local disk connection as input
makeDisplay(byLatLonHDFS,
   name      = &quot;co_vs_time_hdfs&quot;,
   group     = &quot;co&quot;,
   desc      = &quot;Plot of co vs. time for each geographic &#39;square&#39; with with fitted line, illustrating the use of &#39;same&#39; axis limits and a cognostics function, with the data source being a HDFS connection&quot;,
   panelFn   = coPanelFn,
   cogFn     = coCogFn,
   lims      = coTimeLims
)
</code></pre>

</div>


<div class='tab-pane' id='faq'>
<h3>FAQ</h3>

<h4>What should I do if I have an issue or feature request?</h4>

<p>Please post an issue on <a href="https://github.com/hafen/trelliscope/issues">github</a>.</p>

<h4>Who are the intended users of Trelliscope?</h4>

<p>The context for our visualization environment is <em>deep statistical analysis and machine learning</em>, building and validating mathematical models that capture systematic behavior in data while accounting for random behavior.  The consumer of visualization tools in this context is not a field analyst but a statistician with in-depth knowledge about a wealth of statistical methods, the assumptions these methods make about the data, and with experience in fitting and validating models.  In this context, the analyst needs tools that are very flexible that allow for rapid prototyping.  Most importantly, visualization tools in this context need to tie directly into the data analysis environment, as visual and numerical methods cannot be decoupled in the analysis process.</p>

</div>


<div class='tab-pane' id='r-code'>
<h3>R Code</h3>

<p>If you would like to run through all of the code examples in this documentation without having to pick out each line of code from the text, below are files with the R code for each section.  All but the final section on scalable backends should run on a workstation with no other dependencies but the required R packages.  The scalable backend code requires other components to be installed, such as Hadoop or MongoDB.</p>

<ul>
<li><a href="code/1intro.R">Getting Started, Trellis Display, VDBs</a></li>
<li><a href="code/2displays.R">Trelliscope Displays</a></li>
<li><a href="code/4webnotebook.R">Web Notebooks</a></li>
<li><a href="code/5misc.R">Scalable Backends</a></li>
</ul>

</div>

   
   <ul class="pager">
      <li><a href="#" id="previous">&larr; Previous</a></li> 
      <li><a href="#" id="next">Next &rarr;</a></li> 
   </ul>
</div>


</div>
</div>

<hr>

<div class="footer">
   <p>&copy; Ryan Hafen, 2014</p>
</div>
</div> <!-- /container -->

<script src="assets/jquery/jquery.js"></script>
<script type='text/javascript' src='assets/custom/custom.js'></script>
<script src="assets/bootstrap/js/bootstrap.js"></script>
<script src="assets/custom/jquery.ba-hashchange.min.js"></script>
<script src="assets/custom/nav.js"></script>

</body>
</html>